package org.tyszecki.rozkladpkp.widgets;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.tyszecki.rozkladpkp.DatabaseHelper;
import org.tyszecki.rozkladpkp.R;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.util.AttributeSet;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Filter;

public class StationEdit extends  AutoCompleteTextView {

	private ArrayList<String> stationsArr;
	private boolean enableAC = true;
	
	private static final Map<String,String> chmap = new HashMap<String,String>(){
		private static final long serialVersionUID = 1L;
		{
			  put("ą","a");
			  put("ć","c");
			  put("ę","e");
			  put("ł","l");
			  put("ń","n");
			  put("ó","o");
			  put("ś","s");
			  put("ż","z");
			  put("ź","z");
		  }
	};
	
	
	class StationAdapter extends ArrayAdapter<String>{
		private StationFilter mFilter;
		
		
		public StationAdapter(Context context, int textViewResourceId,
				ArrayList<String> arrayList) {
			super(context, textViewResourceId, arrayList);
		}
		
		private class StationFilter extends Filter{
			

			public abstract class Replacer
			{
				/**
				 * A Rewriter does a global substitution in the strings passed to its
				 * 'rewrite' method. It uses the pattern supplied to its constructor, and is
				 * like 'String.replaceAll' except for the fact that its replacement strings
				 * are generated by invoking a method you write, rather than from another
				 * string. This class is supposed to be equivalent to Ruby's 'gsub' when
				 * given a block. This is the nicest syntax I've managed to come up with in
				 * Java so far. It's not too bad, and might actually be preferable if you
				 * want to do the same rewriting to a number of strings in the same method
				 * or class. See the example 'main' for a sample of how to use this class.
				 *
				 * @author Elliott Hughes
				 */
				private Pattern pattern;
				private Matcher matcher;

				/**
				 * Constructs a rewriter using the given regular expression; the syntax is
				 * the same as for 'Pattern.compile'.
				 */
				public Replacer(String regex)
				{
					this.pattern = Pattern.compile(regex);
				}

				/**
				 * Returns the input subsequence captured by the given group during the
				 * previous match operation.
				 */
				public String group(int i)
				{
					return matcher.group(i);
				}

				/**
				 * Overridden to compute a replacement for each match. Use the method
				 * 'group' to access the captured groups.
				 */
				public abstract String replacement();

				/**
				 * Returns the result of rewriting 'original' by invoking the method
				 * 'replacement' for each match of the regular expression supplied to the
				 * constructor.
				 */
				public String rewrite(CharSequence original)
				{
					this.matcher = pattern.matcher(original);
					StringBuffer result = new StringBuffer(original.length());
					while (matcher.find())
					{
						matcher.appendReplacement(result, "");
						result.append(replacement());
					}
					matcher.appendTail(result);
					return result.toString();
				}
			}

			@Override
			protected FilterResults performFiltering(CharSequence constraint) {
				FilterResults results = new FilterResults();
	            if ((constraint == null) || (constraint.length() == 0))
	            {
	                ArrayList<String> list = new ArrayList<String>();
	                results.values = list;
	                results.count = list.size();
	            }
	            else
	            {
	                String constr = constraint.toString().toLowerCase();
	                final ArrayList<String> newItems = new ArrayList<String>();
	                
	                Replacer nopl = new Replacer("[ąćęłńóśżź]")
	                {
	                	public String replacement()
	                	{
	                		return chmap.get(group(0));
	                	}
	                };
	                
	                for (String temp : stationsArr)
	                {
	                    if (nopl.rewrite(temp.toLowerCase()).startsWith((constr)))
	                    {
	                        newItems.add(temp);
	                    }
	                }
	                results.values = newItems;
	                results.count = newItems.size();
	            }
	            return results;
			}

			@SuppressWarnings("unchecked")
			@Override
			protected void publishResults(CharSequence arg0, FilterResults results) {
				if (results.count > 0)
	            {
					clear();
					notifyDataSetChanged();
					for(String t:(ArrayList<String>)results.values)
						add(t);    
	            }
	            else
	                notifyDataSetInvalidated();
			}	
		}
		
		public Filter getFilter()
		{
			if (mFilter == null) 
                mFilter = new StationFilter();
            return mFilter;
		}
	}
	
	
	@SuppressWarnings("unchecked")
	public StationEdit(Context context, AttributeSet attrs) {
        super(context, attrs); 
        setSingleLine();
        setDropDownHeight(-2);
        
        SQLiteDatabase db =  DatabaseHelper.getDb(getContext());
        Cursor cur = db.query("stations", new String[]{"name"}, null, null, null, null, null);
        
        stationsArr = new ArrayList<String>();
        
        while(cur.moveToNext())
        	stationsArr.add(cur.getString(0));
        
        db.close();
        
        //Konieczna jest konwersja Tablica -> ArrayList, ponieważ jeśli podamy tablicę, ArrayAdapter zachowa ją wewnętrznie jako AbstractList.
        //AbstractList nie można modyfikować i program dostanie FC przy próbie filtrowania.
        StationAdapter a = new StationAdapter(getContext(), R.layout.station_edit_item, (ArrayList<String>) stationsArr.clone());
        
        setAdapter(a);  
	};
	
	public String getCurrentSID()
	{
		String cstation = getText().toString();
		
		SQLiteDatabase db =  DatabaseHelper.getDb(getContext());
        Cursor cur = db.query("stations", new String[]{"_id"}, "name = \""+cstation+"\"", null, null, null, null,"1");
		
        if(cur.moveToNext())
        {
        	db.close();
        	return "A=1@O="+cstation+"@L="+Integer.toString(cur.getInt(0))+"@";
        }
        db.close();
        return "";
        
	}
	
	public void setAutoComplete(boolean en)
	{
		enableAC = en;
	}
	
	public boolean autoComplete()
	{
		return enableAC;
	}
}